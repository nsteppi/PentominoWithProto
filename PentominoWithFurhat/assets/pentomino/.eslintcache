[{"A:\\Teaching\\Interaktionsdesign für soziale Roboter\\PentominoWithFurhat\\assets\\pentomino\\src\\index.js":"1","A:\\Teaching\\Interaktionsdesign für soziale Roboter\\PentominoWithFurhat\\assets\\pentomino\\src\\reportWebVitals.js":"2","A:\\Teaching\\Interaktionsdesign für soziale Roboter\\PentominoWithFurhat\\assets\\pentomino\\src\\App.js":"3","A:\\Teaching\\Interaktionsdesign für soziale Roboter\\PentominoWithFurhat\\assets\\pentomino\\src\\config.js":"4","A:\\Teaching\\Interaktionsdesign für soziale Roboter\\PentominoWithFurhat\\assets\\pentomino\\src\\pento-objects\\HelperPentoShapes.js":"5","A:\\Teaching\\Interaktionsdesign für soziale Roboter\\PentominoWithFurhat\\assets\\pentomino\\src\\pento-objects\\PentoBoard.js":"6","A:\\Teaching\\Interaktionsdesign für soziale Roboter\\PentominoWithFurhat\\assets\\pentomino\\src\\pento-objects\\HelperDrawComplexShapes.js":"7","A:\\Teaching\\Interaktionsdesign für soziale Roboter\\PentominoWithFurhat\\assets\\pentomino\\src\\pento-objects\\HelperDrawingBoard.js":"8","A:\\Teaching\\Interaktionsdesign für soziale Roboter\\PentominoWithFurhat\\assets\\pentomino\\src\\pento-objects\\PentoBlock.js":"9","A:\\Teaching\\Interaktionsdesign für soziale Roboter\\PentominoWithFurhat\\assets\\pentomino\\src\\pento-objects\\HelperDrawingBlocks.js":"10","A:\\Teaching\\Interaktionsdesign für soziale Roboter\\PentominoWithFurhat\\assets\\pentomino\\src\\pento-objects\\PentoShape.js":"11"},{"size":504,"mtime":1614162293799,"results":"12","hashOfConfig":"13"},{"size":362,"mtime":1612002030650,"results":"14","hashOfConfig":"13"},{"size":10038,"mtime":1614351602127,"results":"15","hashOfConfig":"13"},{"size":1656,"mtime":1614170735765,"results":"16","hashOfConfig":"13"},{"size":8670,"mtime":1614241517756,"results":"17","hashOfConfig":"13"},{"size":5084,"mtime":1614241517784,"results":"18","hashOfConfig":"13"},{"size":8900,"mtime":1614269167150,"results":"19","hashOfConfig":"13"},{"size":138,"mtime":1614158160839,"results":"20","hashOfConfig":"13"},{"size":8626,"mtime":1614241517782,"results":"21","hashOfConfig":"13"},{"size":2389,"mtime":1614241517752,"results":"22","hashOfConfig":"13"},{"size":17934,"mtime":1614241517786,"results":"23","hashOfConfig":"13"},{"filePath":"24","messages":"25","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"14rz29j",{"filePath":"26","messages":"27","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"28","messages":"29","errorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":"30"},{"filePath":"31","messages":"32","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"33","messages":"34","errorCount":0,"warningCount":16,"fixableErrorCount":0,"fixableWarningCount":0,"source":"35"},{"filePath":"36","messages":"37","errorCount":0,"warningCount":22,"fixableErrorCount":0,"fixableWarningCount":0,"source":"38"},{"filePath":"39","messages":"40","errorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"41"},{"filePath":"42","messages":"43","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"44","messages":"45","errorCount":0,"warningCount":12,"fixableErrorCount":0,"fixableWarningCount":0,"source":"46"},{"filePath":"47","messages":"48","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"49"},{"filePath":"50","messages":"51","errorCount":0,"warningCount":17,"fixableErrorCount":0,"fixableWarningCount":0,"source":"52"},"A:\\Teaching\\Interaktionsdesign für soziale Roboter\\PentominoWithFurhat\\assets\\pentomino\\src\\index.js",[],"A:\\Teaching\\Interaktionsdesign für soziale Roboter\\PentominoWithFurhat\\assets\\pentomino\\src\\reportWebVitals.js",[],"A:\\Teaching\\Interaktionsdesign für soziale Roboter\\PentominoWithFurhat\\assets\\pentomino\\src\\App.js",["53","54","55","56","57","58","59","60","61"],"import './css/normalize.css';\r\nimport './css/skeleton.css';\r\nimport './css/style.css';\r\nimport './css/App.css';\r\nimport React, { useEffect, useReducer, useState, useRef } from 'react'\r\nimport { pento_I } from \"./pento-objects/HelperPentoShapes\";\r\nimport { PentoBoard } from \"./pento-objects/PentoBoard\";\r\nimport { PentoConfig } from \"./config\";\r\nimport { createNewPentoPieceInShape, generateElephantShape } from \"./pento-objects/HelperDrawComplexShapes\";\r\nimport Furhat from 'furhat-gui'\r\n\r\n\r\nconst App = () => {\r\n\r\n  const pento_config = new PentoConfig()\r\n\r\n  const n_blocks = pento_config.n_blocks;\r\n  const board_size = pento_config.board_size;\r\n  const block_size = pento_config.block_size;\r\n  const grid_x = 0;\r\n  const grid_y = 0;\r\n\r\n  const game_time = 600;\r\n\r\n  const grid_config = {\r\n    \"n_blocks\": n_blocks,\r\n    \"board_size\": board_size,\r\n    \"block_size\": block_size,\r\n    \"x\": grid_x,\r\n    \"y\": grid_y\r\n  }\r\n  const initialState = {\r\n    \"left_board\": [],\r\n    \"right_board\": [],\r\n    \"game\": {\r\n      \"status\": \"initial\",\r\n      \"startTime\": undefined,\r\n      \"time\": game_time,\r\n    },\r\n    \"selected\": \"\"\r\n  }\r\n\r\n\r\n  const gameTimeHandler = useRef();\r\n\r\n\r\n  const [initialShapes, setInitialShapes] = useState([]);\r\n  const [placedShapes, setPlacedShapes] = useState([]);\r\n\r\n  const [activeShape, setActiveShape] = useState([]);\r\n\r\n  const [initialized, setInitialized] = useState(false)\r\n\r\n\r\n  const [gameState, dispatch] = useReducer((state, action) => {\r\n    switch (action.type) {\r\n      case 'gameStart':\r\n        return {\r\n          ...state,\r\n          game: {\r\n            ...state.game,\r\n            status: 'ongoing',\r\n            startTime: new Date().getTime()\r\n          }\r\n        };\r\n      case 'selectPiece': {\r\n        return {\r\n          ...state,\r\n          selected: action.piece.name\r\n        };\r\n      };\r\n      case 'deselectPiece': {\r\n        return {\r\n          ...state,\r\n          selected: \"\"\r\n        };\r\n      }\r\n      case 'addToRightBoard':\r\n        return {\r\n          ...state,\r\n          right_board: [...state.right_board, action.piece]\r\n        };\r\n      case 'addToLeftBoard':\r\n        return {\r\n          ...state,\r\n          left_board: [...state.left_board, action.piece]\r\n        };\r\n      case 'removeFromLeftBoard':\r\n        let filtered_list = state.left_board.filter(item => item.name !== action.piece.name)\r\n        return {\r\n          ...state,\r\n          left_board: filtered_list\r\n        };\r\n      case 'gameWon':\r\n        return {\r\n          ...state,\r\n          game: {\r\n            ...state.game,\r\n            status: 'won',\r\n            startTime: new Date().getTime()\r\n          }\r\n        };\r\n      case 'refreshTime':\r\n\r\n        const currentTime = new Date().getTime();\r\n        const newDiff = game_time - Math.floor((currentTime - state.game.startTime) / 1000.0);\r\n        let newStatus = state.game.status;\r\n        if (newDiff <= 0){\r\n          newStatus = 'lost'\r\n        }\r\n\r\n        return {\r\n          ...state,\r\n          game: {\r\n            ...state.game,\r\n            status: newStatus,\r\n            time: newDiff\r\n          }\r\n        };\r\n\r\n      default:\r\n        return state\r\n\r\n    }\r\n  }, initialState);\r\n\r\n\r\n  const renderButtons = () => {\r\n    return initialShapes.map(element => {\r\n      return <button id={\"pento_\" + element.type} onClick={() => {\r\n        selectPentoPiece(element.name)\r\n      }}> {pento_config.get_color_name(element.color)} {element.type} </button>\r\n    })\r\n  };\r\n\r\n  /**\r\n   * This method is called when the respective button for a pento piece is pressed, or when\r\n   * the \"pick\" event is received over the interface.\r\n   */\r\n  const selectPentoPiece = (pento_name) => {\r\n    if (activeShape.length > 0 && activeShape[0].name == pento_name) {\r\n      setActiveShape([])\r\n    } else {\r\n      setActiveShape(initialShapes.filter(item => item.name == pento_name));\r\n    }\r\n  };\r\n\r\n  /**\r\n   * This method is called when the \"Deselect\" button is pressed, or when\r\n   * the \"deselect\" event is received over the interface.\r\n   */\r\n  const deselect = () => {\r\n    setActiveShape([])\r\n  };\r\n\r\n  /**\r\n   * This method is called when the \"Start Game\" button is pressed, or when\r\n   * the \"start_game\" event is received over the interface.\r\n   */\r\n  const startGame = () => {\r\n    setPlacedShapes([]);\r\n    setActiveShape([]);\r\n    setInitialShapes(generateElephantShape(\"elephant\", pento_config, grid_config));\r\n\r\n    dispatch({type: 'gameStart'})\r\n  };\r\n\r\n  /**\r\n   * This method is called when the \"Place selected\" button is pressed, or when\r\n   * the \"place_selected\" event is received over the interface.\r\n   */\r\n  const placeSelected = () => {\r\n    if (activeShape.length > 0) {\r\n      let selected_shape = activeShape[0].name;\r\n      let to_replace = null;\r\n      initialShapes.forEach(el => {\r\n        if (el.name == selected_shape) {\r\n          to_replace = el\r\n        }\r\n      });\r\n\r\n      let new_shape = createNewPentoPieceInShape(\"elephant\", pento_config, grid_config, to_replace.type, to_replace.color, to_replace.id);\r\n\r\n      const newPiece = pentoPieceToObj(new_shape.name, new_shape.type, new_shape.color, new_shape.x, new_shape.y);\r\n      dispatch({type: 'addToRightBoard', piece: newPiece});\r\n      dispatch({type: 'removeFromLeftBoard', piece: to_replace});\r\n\r\n      setPlacedShapes(placedShapes.concat(new_shape));\r\n      setInitialShapes(initialShapes.filter(item => item.name !== to_replace.name));\r\n      setActiveShape([])\r\n    }\r\n  };\r\n\r\n  const pentoPieceToObj = (name, type, color_code, x, y) => {\r\n    let color = pento_config.get_color_name(color_code)\r\n    return {name, type, color, location: { x, y}}\r\n  };\r\n\r\n  useEffect(() => {\r\n    if (gameState.game.status === 'ongoing') {\r\n      console.log('Game status changed to ongoing');\r\n      initialShapes.forEach(el => {\r\n        const newPiece = pentoPieceToObj(el.name, el.type, el.color, el.x, el.y);\r\n        dispatch({type: 'addToLeftBoard', piece: newPiece});\r\n      });\r\n\r\n      gameTimeHandler.current = setInterval(() => {\r\n        dispatch({type: 'refreshTime'});\r\n        sendDataToFurhat()\r\n      }, 500)\r\n    }\r\n    if (['lost', 'won'].includes(gameState.game.status)){\r\n      alert(`You ${gameState.game.status} the game!`);\r\n      if (gameTimeHandler.current){\r\n        clearInterval(gameTimeHandler.current)\r\n      }\r\n    }\r\n  }, [gameState.game.status]);\r\n\r\n  useEffect(() => {\r\n    if (gameState.game.status === 'ongoing' && initialShapes?.length === 0) {\r\n      dispatch({type: 'gameWon'})\r\n    }\r\n  }, [initialShapes, gameState.game.status]);\r\n\r\n  useEffect(() => {\r\n    if (activeShape && activeShape.length > 0) {\r\n      dispatch({type: 'selectPiece', piece: activeShape[0]});\r\n    }\r\n    else {\r\n      dispatch({type: 'deselectPiece'})\r\n    }\r\n  }, [activeShape]);\r\n\r\n  useEffect(() => {\r\n\r\n    Furhat(function (furhat) {\r\n\r\n      window.furhat = furhat\r\n      // We subscribe to the event to start the game\r\n      furhat.subscribe('startGame', function () {\r\n        startGame()\r\n      });\r\n\r\n      // We subscribe to the event to select a piece. We need to send the name of the shape as a parameter\r\n      furhat.subscribe('selectPiece', function (shape_name) {\r\n        selectPentoPiece(shape_name)\r\n      });\r\n\r\n      // We subscribe to the event to clear the selection of the current piece\r\n      furhat.subscribe('deselectPiece', function () {\r\n        deselect()\r\n      });\r\n\r\n      // We subscribe to the event to place the current piece on the right game board\r\n      furhat.subscribe('startPlacing', function () {\r\n        placeSelected()\r\n      })\r\n    })\r\n\r\n  }, [])\r\n\r\n  const initializationMonitor = () => {\r\n\r\n    if(!window.furhat) {\r\n      setTimeout(initializationMonitor, 1000)\r\n    }\r\n    else {\r\n      setInitialized(true)\r\n    }\r\n\r\n  }\r\n\r\n  useEffect(() => {\r\n    initializationMonitor()\r\n  }, [])\r\n\r\n  const sendDataToFurhat = () => {\r\n    if(window.furhat) {\r\n      window.furhat.send({\r\n        event_name: \"GameStateUpdate\",\r\n        data: gameState.JSON()\r\n      })\r\n    }\r\n  }\r\n\r\n\r\n  return (\r\n    <div className=\"App\">\r\n      <div className=\"twelve columns\">\r\n        <h5>Pentomino Game</h5>\r\n      </div>\r\n      <div className=\"row\">\r\n        <div className=\"six columns\">\r\n          <button id=\"startBtn\" style={{ marginRight: 50 }} onClick={() => startGame()}>Start new game</button>\r\n          <button id=\"placeBtn\" style={{ marginRight: 50 }} onClick={() => placeSelected()}>Place selected</button>\r\n          <button id=\"placeBtn\" onClick={() => deselect()}>Deselected Piece</button>\r\n        </div>\r\n        <div className=\"six columns\">\r\n          <div style={{ color: \"#555\", fontSize: \"16px\" }}>Game State: {gameState.game.status}</div>\r\n          <div style={{ color: \"#555\", fontSize: \"16px\" }}>Remaining Game Time: {gameState.game.time}</div>\r\n        </div>\r\n      </div>\r\n      <hr />\r\n      <div className=\"row\">\r\n        <div className=\"six columns\">\r\n          <PentoBoard shapes={initialShapes}\r\n                      activeShape={activeShape[0]}\r\n                      grid_properties={{\r\n                        \"title\": \"Initial\",\r\n                        \"with_grid\": true,\r\n                        \"with_tray\": true,\r\n                        \"x\": grid_x,\r\n                        \"y\": grid_y\r\n                      }}\r\n                      config={{ \"n_blocks\": n_blocks, \"board_size\": board_size, \"block_size\": block_size }}\r\n          />\r\n        </div>\r\n        <div className=\"six columns\">\r\n          <PentoBoard shapes={placedShapes}\r\n                      grid_properties={{\r\n                        \"title\": \"Elephant\",\r\n                        \"with_grid\": true,\r\n                        \"with_tray\": true,\r\n                        \"x\": grid_x,\r\n                        \"y\": grid_y\r\n                      }}\r\n                      config={{ \"n_blocks\": n_blocks, \"board_size\": board_size, \"block_size\": block_size }}\r\n          />\r\n        </div>\r\n      </div>\r\n      <div>\r\n        {renderButtons()}\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default App;\r\n","A:\\Teaching\\Interaktionsdesign für soziale Roboter\\PentominoWithFurhat\\assets\\pentomino\\src\\config.js",[],"A:\\Teaching\\Interaktionsdesign für soziale Roboter\\PentominoWithFurhat\\assets\\pentomino\\src\\pento-objects\\HelperPentoShapes.js",["62","63","64","65","66","67","68","69","70","71","72","73","74","75","76","77"],"/**\r\n * Draw point (one block shape)\r\n */\r\nimport {Block} from \"./PentoBlock\";\r\nimport {Shape} from \"./PentoShape\";\r\n\r\nconst pento_point = (shape) => {\r\n    var block = pento_create_block(0, 0, shape.block_size, shape.color);\r\n    shape.add_block(block);\r\n}\r\n\r\nconst pento_create_block = (x, y, block_size, color) => {\r\n    return new Block(x, y, block_size, block_size, color)\r\n};\r\n\r\n// draw F \r\nconst pento_F = (shape) =>  {\r\n    // Draw blocks\r\n    for (var y = -1; y < 2; y++) {\r\n        shape.add_block(pento_create_block(0, + y * shape.block_size, shape.block_size, shape.color));\r\n    }\r\n\r\n    if (shape.is_mirrored) {\r\n        shape.add_block(pento_create_block(shape.block_size, - shape.block_size, shape.block_size, shape.color));\r\n        shape.add_block(pento_create_block(- shape.block_size, 0, shape.block_size, shape.color));\r\n    } else {\r\n        shape.add_block(pento_create_block(- shape.block_size, - shape.block_size, shape.block_size, shape.color));\r\n        shape.add_block(pento_create_block(shape.block_size, 0, shape.block_size, shape.color));\r\n    }\r\n};\r\n\r\n// Draw I\r\nconst pento_I = (shape) => {\r\n    // Draw blocks\r\n    for (var y = -2; y < 3; y++) {\r\n        var block = pento_create_block(0, y * shape.block_size, shape.block_size, shape.color);\r\n        shape.add_block(block);\r\n    }\r\n};\r\n\r\n// Draw L\r\nconst pento_L = (shape) => {\r\n    // Draw blocks\r\n    for (var y = -2; y < 2; y++) {\r\n        var block = pento_create_block(0, y * shape.block_size, shape.block_size, shape.color);\r\n        shape.add_block(block);\r\n    }\r\n\r\n    if (shape.is_mirrored) {\r\n        var block = pento_create_block(shape.block_size, 1 * shape.block_size, shape.block_size, shape.color);\r\n    } else {\r\n        var block = pento_create_block(- shape.block_size, 1 * shape.block_size, shape.block_size, shape.color);\r\n    }\r\n    shape.add_block(block);\r\n};\r\n\r\n// draw N\r\nconst pento_N = (shape) => {\r\n\r\n    // Draw blocks\r\n    for (var y = -1; y < 2; y++) {\r\n        var block = pento_create_block(0, + y * shape.block_size, shape.block_size, shape.color);\r\n        shape.add_block(block);\r\n    }\r\n\r\n    for (var y = -2; y < 0; y++) {\r\n        if (shape.is_mirrored) {\r\n            var block = pento_create_block(- shape.block_size, + y * shape.block_size, shape.block_size, shape.color);\r\n        } else {\r\n            var block = pento_create_block(+ shape.block_size, + y * shape.block_size, shape.block_size, shape.color);\r\n        }\r\n        shape.add_block(block);\r\n    }\r\n};\r\n\r\n// draw P\r\nconst pento_P = (shape) => {\r\n\r\n    // Draw blocks\r\n    for (var y = -1; y < 2; y++) {\r\n        var block = pento_create_block(0, y * shape.block_size, shape.block_size, shape.color);\r\n        shape.add_block(block);\r\n    }\r\n\r\n    for (var y = 0; y < 2; y++) {\r\n        if (shape.is_mirrored) {\r\n            var block = pento_create_block(shape.block_size, + y * shape.block_size, shape.block_size, shape.color);\r\n        } else {\r\n            var block = pento_create_block(- shape.block_size, + y * shape.block_size, shape.block_size, shape.color);\r\n        }\r\n        shape.add_block(block);\r\n    }\r\n};\r\n\r\n// Draw T\r\nconst pento_T = (shape) => {\r\n    // Draw blocks (no mirrored version here)\r\n    for (var x = -1; x < 2; x++) {\r\n        var block = pento_create_block(+ x * shape.block_size, 0, shape.block_size, shape.color);\r\n        shape.add_block(block);\r\n    }\r\n\r\n    shape.add_block(pento_create_block(shape.block_size, - shape.block_size, shape.block_size, shape.color));\r\n    shape.add_block(pento_create_block(shape.block_size, + shape.block_size, shape.block_size, shape.color));\r\n};\r\n\r\n// draw U\r\nconst pento_U = (shape) => {\r\n    // Draw blocks (no mirrored version here)\r\n    for (var y = -1; y < 2; y++) {\r\n        var block = pento_create_block(0, y * shape.block_size, shape.block_size, shape.color);\r\n        shape.add_block(block);\r\n    }\r\n\r\n    var block = pento_create_block(shape.block_size, - shape.block_size, shape.block_size, shape.color);\r\n    shape.add_block(block);\r\n\r\n    var block = pento_create_block(shape.block_size, shape.block_size, shape.block_size, shape.color);\r\n    shape.add_block(block);\r\n};\r\n\r\n// draw V\r\nconst pento_V = (shape) => {\r\n    // Draw blocks (no mirrored version here)\r\n    for (var y = -1; y < 2; y++) {\r\n        var block = pento_create_block(- shape.block_size, y * shape.block_size, shape.block_size, shape.color);\r\n        shape.add_block(block);\r\n    }\r\n\r\n    for (var x = 0; x < 2; x++) {\r\n        var block = pento_create_block(x * shape.block_size, - shape.block_size, shape.block_size, shape.color);\r\n        shape.add_block(block);\r\n    }\r\n};\r\n\r\n// draw W\r\nconst pento_W = (shape) => {\r\n\r\n    // Draw blocks (no mirrored version here)\r\n    for (var y = -1; y < 1; y++) {\r\n        var block = pento_create_block(- shape.block_size, y * shape.block_size, shape.block_size, shape.color);\r\n        shape.add_block(block);\r\n    }\r\n\r\n    for (var y = 0; y < 2; y++) {\r\n        var block = pento_create_block(0, y * shape.block_size, shape.block_size, shape.color);\r\n        shape.add_block(block);\r\n    }\r\n\r\n    var block = pento_create_block(shape.block_size, shape.block_size, shape.block_size, shape.color);\r\n    shape.add_block(block);\r\n};\r\n\r\n// Draw X\r\nconst pento_X = (shape) => {\r\n    // Draw blocks (no mirrored version here)\r\n    for (var y = -1; y < 2; y++) {\r\n        var block = pento_create_block(0, y * shape.block_size, shape.block_size, shape.color);\r\n        shape.add_block(block);\r\n    }\r\n\r\n    shape.add_block(pento_create_block(- shape.block_size, 0, shape.block_size, shape.color));\r\n    shape.add_block(pento_create_block(shape.block_size, 0, shape.block_size, shape.color));\r\n};\r\n\r\n// Draw Y\r\nconst pento_Y = (shape) => {\r\n    // Draw blocks\r\n    for (var x = -2; x < 2; x++) {\r\n        var block = pento_create_block(x * shape.block_size, 0, shape.block_size, shape.color);\r\n        shape.add_block(block);\r\n    }\r\n\r\n    if (shape.is_mirrored) {\r\n        var block = pento_create_block(0, - shape.block_size, shape.block_size, shape.color);\r\n    } else {\r\n        var block = pento_create_block(0, + shape.block_size, shape.block_size, shape.color);\r\n    }\r\n    shape.add_block(block);\r\n};\r\n\r\n// draw Z\r\nconst pento_Z = (shape) => {\r\n    // Draw blocks\r\n    for (var x = -1; x < 2; x++) {\r\n        var block = pento_create_block(x * shape.block_size, 0, shape.block_size, shape.color);\r\n        shape.add_block(block);\r\n    }\r\n\r\n    if (shape.is_mirrored) {\r\n        shape.add_block(pento_create_block(- shape.block_size, - shape.block_size, shape.block_size, shape.color));\r\n        shape.add_block(pento_create_block(shape.block_size, shape.block_size, shape.block_size, shape.color));\r\n    } else {\r\n        shape.add_block(pento_create_block(- shape.block_size, shape.block_size, shape.block_size, shape.color));\r\n        shape.add_block(pento_create_block(shape.block_size, -  shape.block_size, shape.block_size, shape.color));\r\n    }\r\n\r\n};\r\n\r\n\r\nconst _new_pento_shape = (id, type, color, is_mirrored, rotation, block_size) => {\r\n    return new Shape(id, type, color, is_mirrored, rotation == null ? 0 : rotation, block_size)\r\n};\r\n\r\nexport const pento_create_shape = (id, x, y, type, color, is_mirrored, rotation, block_size) => {\r\n    //create empty shape\r\n    var new_shape = _new_pento_shape(id, type, color, is_mirrored, rotation, block_size);\r\n\r\n    switch (type) {\r\n        case 'point':\r\n            pento_point(new_shape);\r\n            break;\r\n        case 'F':\r\n            pento_F(new_shape);\r\n            break;\r\n        case 'I':\r\n            pento_I(new_shape);\r\n            break;\r\n        case 'L':\r\n            pento_L(new_shape);\r\n            break;\r\n        case 'N':\r\n            pento_N(new_shape);\r\n            break;\r\n        case 'P':\r\n            pento_P(new_shape);\r\n            break;\r\n        case 'T':\r\n            pento_T(new_shape);\r\n            break;\r\n        case 'U':\r\n            pento_U(new_shape);\r\n            break;\r\n        case 'V':\r\n            pento_V(new_shape);\r\n            break;\r\n        case 'W':\r\n            pento_W(new_shape);\r\n            break;\r\n        case 'X':\r\n            pento_X(new_shape);\r\n            break;\r\n        case 'Y':\r\n            pento_Y(new_shape);\r\n            break;\r\n        case 'Z':\r\n            pento_Z(new_shape);\r\n            break;\r\n        default:\r\n            console.log('Unsupported shape type: ' + type);\r\n            return;\r\n    }\r\n\r\n    // Important: Closing the shapes disabled editing and\r\n    // calculates center point for rotations\r\n    new_shape.close();\r\n\r\n    // move and rotate\r\n    new_shape.moveTo(x, y);\r\n    new_shape.rotate(rotation);\r\n\r\n    return new_shape\r\n};","A:\\Teaching\\Interaktionsdesign für soziale Roboter\\PentominoWithFurhat\\assets\\pentomino\\src\\pento-objects\\PentoBoard.js",["78","79","80","81","82","83","84","85","86","87","88","89","90","91","92","93","94","95","96","97","98","99"],"import React, {Component, useEffect, useRef} from \"react\";\r\nimport {pento_create_shape} from \"./HelperPentoShapes\";\r\nimport {draw_shape, draw_shape_border} from \"./HelperDrawingBlocks\";\r\n\r\nexport const PentoBoard = ({grid_properties, shapes, config, activeShape}) => {\r\n\r\n    const canvasRef = useRef(null)\r\n\r\n    const title = grid_properties?.title || \"test\";\r\n    const pento_config = config;\r\n    const pento_shapes = shapes;\r\n    const active_shape = activeShape\r\n\r\n    // board size and grid parameters\r\n    const pento_grid_cols\t= config.n_blocks;\r\n    const pento_grid_rows\t= config.n_blocks;\r\n    const width\t\t\t\t= config.board_size;\r\n    const height\t\t\t\t= config.board_size;\r\n    const pento_block_size\t= config.block_size;\r\n    const pento_grid_color = 'gray';\r\n    const pento_grid_x = grid_properties.x;\r\n    const pento_grid_y = grid_properties.y;\r\n\r\n    // pento game parameters\r\n    const show_grid = grid_properties.with_grid;\r\n    const pento_read_only = false;\r\n    const pento_lock_on_grid = true;\t\t\t// make pieces jump to full grid cells\r\n    const pento_prevent_collision = false;\r\n    let pento_active_shape = null;\r\n    const pento_with_tray = grid_properties.with_tray;\r\n    const remove_at_rightclick = false;\t\t// delete shapes by right-clicking them\r\n    const deactivate_at_canvasleave = true;\t// reset active shape when leaving the canvas\r\n\r\n    // actions\r\n    const _actions = ['move', 'rotate', 'connect', 'flip'];\r\n\r\n    const draw = ctx => {\r\n        pento_shapes.forEach((s) => {\r\n            if (active_shape == null || s.name != active_shape.name) {\r\n                s.remove_highlight()\r\n                draw_shape(ctx,s,{offsetX: 0, offsetY: 0})\r\n                draw_shape_border(ctx,s,{offsetX: 0, offsetY: 0})\r\n            }\r\n        })\r\n        // make sure to draw active shape last\r\n        if (active_shape!= null) {\r\n            active_shape.set_highlight(\"red\");\r\n            draw_shape(ctx, active_shape, {offsetX: 0, offsetY: 0});\r\n            draw_shape_border(ctx, active_shape, {offsetX: 0, offsetY: 0});\r\n        }\r\n\r\n    };\r\n\r\n    const init_board = (canvas, ctx) => {\r\n        if (pento_with_tray) {\r\n            canvas.height = height;\r\n            canvas.width = width;\r\n            draw_line(ctx, pento_grid_x, pento_grid_y + height, pento_grid_x + width+200, pento_grid_y+height, 'black', 'separator');\r\n            //this.draw_text(pento_grid_x+40, pento_grid_y+ height+10, 'Tray');\r\n        }\r\n    };\r\n\r\n\r\n    const init_grid = (ctx) => {\r\n\r\n        //draws the outer border\r\n        draw_line(ctx, pento_grid_x, pento_grid_y, pento_grid_x+width, pento_grid_y, 'black')\r\n        draw_line(ctx, pento_grid_x+width, pento_grid_y, pento_grid_x+width, pento_grid_y+height, 'black')\r\n        draw_line(ctx, pento_grid_x, pento_grid_y+height, pento_grid_x+width, pento_grid_y+height, 'black')\r\n        draw_line(ctx, pento_grid_x, pento_grid_y, pento_grid_x, pento_grid_y+height, 'black')\r\n\r\n\r\n        if (show_grid) {\r\n            for (var i = 0; i <= pento_grid_rows; i++) {\r\n                draw_line(ctx, pento_grid_x, pento_grid_y + i * pento_block_size,\r\n                    pento_grid_x + width, pento_grid_y + i * pento_block_size, pento_grid_color);\r\n            }\r\n\r\n            for (var i = 0; i <= pento_grid_cols; i++) {\r\n                draw_line(ctx,pento_grid_x + i * pento_block_size, pento_grid_y + 0,\r\n                    pento_grid_x + i * pento_block_size, pento_grid_y + height, pento_grid_color);\r\n            }\r\n        }\r\n    };\r\n\r\n\r\n    const draw_line = (ctx, x, y, x2, y2, color, name) => {\r\n        if (name == undefined) {\r\n            name = 'line' + Math.random();\r\n        }\r\n        ctx.beginPath();\r\n        ctx.moveTo(x, y);\r\n        ctx.lineTo(x2, y2);\r\n        ctx.strokeWidth = 1;\r\n        ctx.strokeStyle = color;\r\n        ctx.stroke();\r\n    };\r\n\r\n\r\n    // functions to access grid borders\r\n    const left_edge = () => {\r\n        return pento_grid_x\r\n    };\r\n\r\n    const right_edge = () => {\r\n        return pento_grid_x + this.width\r\n    };\r\n\r\n    const upper_edge = () => {\r\n        return pento_grid_y\r\n    };\r\n\r\n    const lower_edge = () =>  {\r\n        return pento_grid_y + this.height\r\n    };\r\n\r\n    const get_shapes = () => {\r\n        return pento_shapes;\r\n    };\r\n\r\n    const get_actions = () => {\r\n        return _actions;\r\n    };\r\n\r\n    /**\r\n     * @return shape with given name\r\n     */\r\n    const get_shape = (name) => {\r\n        return pento_shapes[name];\r\n    };\r\n\r\n    /**\r\n     * Unselect the currently active shape\r\n     */\r\n    const clear_selections = () => {\r\n        if (this.pento_active_shape != null){\r\n            this.pento_active_shape.set_deactive();\r\n        }\r\n        this.pento_active_shape = null;\r\n\r\n        //draw(); TODO\r\n    };\r\n\r\n\r\n\r\n\r\n\r\n\r\n    useEffect(() => {\r\n\r\n        const canvas = canvasRef.current\r\n        const context = canvas.getContext('2d')\r\n\r\n        //Our draw come here\r\n        init_board(canvas, context)\r\n        init_grid(context)\r\n        draw(context)\r\n    }, [shapes, activeShape])\r\n\r\n    return <canvas ref={canvasRef} />\r\n}\r\n","A:\\Teaching\\Interaktionsdesign für soziale Roboter\\PentominoWithFurhat\\assets\\pentomino\\src\\pento-objects\\HelperDrawComplexShapes.js",["100","101","102","103","104","105","106"],"import {grid_cell_to_coordinates} from \"./HelperDrawingBoard\";\r\nimport {pento_create_shape} from \"./HelperPentoShapes\";\r\n\r\nconst configPerShape = (shape, n_blocks) => {\r\n\r\n    let shape_config = {\"x\": -1, \"y\": -1, \"coords\": {}}\r\n\r\n    switch (shape) {\r\n\r\n        case \"elephant\":\r\n            shape_config[\"x\"] = Math.max(0, Math.floor((n_blocks-11) / 2));\r\n            shape_config[\"y\"] = Math.max(0, Math.floor((n_blocks-9) / 2));\r\n            shape_config[\"coords\"] = {\r\n                'F': {'x':4 , 'y':4},\r\n                'I': {'x':3 , 'y':6},\r\n                'L': {'x':10 , 'y':7},\r\n                'N': {'x':4 , 'y':7},\r\n                'P': {'x':7 , 'y':3},\r\n                'T': {'x':8 , 'y':6},\r\n                'U': {'x':0 , 'y':1},\r\n                'V': {'x':1 , 'y':4},\r\n                'W': {'x':9 , 'y':3},\r\n                'X': {'x':2 , 'y':1},\r\n                'Y': {'x':5 , 'y':2},\r\n                'Z': {'x':7 , 'y':5}\r\n            };\r\n            return shape_config;\r\n        default:\r\n            return shape_config\r\n    }\r\n};\r\n\r\n\r\n/**\r\n * This generates all shapes that are required to fill the elephant\r\n */\r\nexport const generateElephantShape = (shape, pento_config, grid_config) => {\r\n\r\n    // set value ranges for random selection\r\n    const columns =\t\t\t[...Array(grid_config.n_blocks).keys()];\r\n    const rows =\t\t\t\t[...Array(grid_config.n_blocks).keys()];\r\n\r\n    // generation parameters\r\n    const colors =\t\t\tpento_config.get_pento_colors();\r\n    const pento_types =\t\tpento_config.get_pento_types();\r\n\r\n    let generated_shapes = \t[];\r\n\r\n    //x, y and coordinates for specific shape\r\n    const shape_config = configPerShape(shape, grid_config.n_blocks)\r\n\r\n    for (let id=0; id<pento_types.length; id++) {\r\n        let rand_color = colors[Math.floor(Math.random() * colors.length)];\r\n\r\n        const pento_types =\t\tpento_config.get_pento_types();\r\n        let pento_piece = pento_types[id]\r\n\r\n\r\n        let new_shape = createNewPentoPieceInShape(shape, pento_config, grid_config, pento_piece, rand_color, id);\r\n        generated_shapes.push(new_shape.copy(id));\r\n    }\r\n\r\n    // now move, rotate, flip shape randomly to create initial board\r\n    create_initial_state(generated_shapes, ['rotate', 'move', 'flip'], grid_config);\r\n\r\n    return generated_shapes\r\n};\r\n\r\nexport const createNewPentoPieceInShape = (shape, pento_config, grid_config, pento_piece, color, id) => {\r\n    const shape_config = configPerShape(shape, grid_config.n_blocks)\r\n\r\n    console.log(\"Pento Piece \" + pento_piece);\r\n    // place on elephant board (predefined position)\r\n    let eleX = shape_config[\"x\"] + shape_config[\"coords\"][pento_piece]['x'];\r\n    let eleY = shape_config[\"y\"] + shape_config[\"coords\"][pento_piece]['y'];\r\n    let coords = grid_cell_to_coordinates(eleX, eleY,grid_config.block_size);\r\n\r\n    //console.log({\"id\":id, \"x\": coords[0], \"y\": coords[1], \"type\": pento_types[id], \"color\": rand_color})\r\n    // create shape for the elephant board: without flip or rotation\r\n    let new_shape = pento_create_shape(id, coords[0], coords[1], pento_piece, color, false, 0, grid_config.block_size);\r\n\r\n    return new_shape.copy(id)\r\n}\r\n\r\n/**\r\n * Create initial state by manipulating the target state by n actions\r\n * @param {copy of target shapes} shapes\r\n * @param {actions} nactions\r\n */\r\nconst create_initial_state = (shapes, actions, grid_config) => {\r\n    // likelihood of an action (rotate, flip) being performed\r\n    let action_likelihood = 0.5;\r\n    let action_counter = 0;\r\n\r\n    // remove action 'connect' if present\r\n    if (actions.includes('connect')) {\r\n        actions.splice(actions.indexOf('connect'), 1);\r\n    }\r\n    for (let shape of shapes) {\r\n        //this.pento_board_initial.place_shape(shape);\r\n\r\n        // MOVE, ROTATE, FLIP\r\n        for (let action of ['move', 'rotate', 'flip']) {\r\n            if (!actions.includes(action)) {\r\n                console.log('PentoBoard does not support action ' + action);\r\n            } else {\r\n                // Always perform 'move'. Decide randomly whether to perform 'rotate' and 'flip'\r\n                if (action == 'move' || Math.random() < action_likelihood) {\r\n                    // generate a valid set of parameters\r\n                    let params = generate_params(shape, action, grid_config);\r\n                    execute_action(action, shape, params);\r\n                    let attempts = 0; // assure loop termination if action is impossible due to board size\r\n                    while (!isValidAction(action, shape, shapes, grid_config) && attempts < 40) {\r\n                        shape.rollback(1);\r\n                        params = generate_params(shape, action, grid_config);\r\n                        execute_action(action, shape, params);\r\n                        ++attempts;\r\n                    }\r\n                    // emit warning if invalid parameters where used\r\n                    if (attempts >= 40) {\r\n                        console.log(`No valid parameters were found for shape ${shape.name} and action ${action} during ${attempts} iterations. Result may contain overlaps.`);\r\n                        continue;\r\n                    }\r\n\r\n                    ++action_counter;\r\n                }\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\nconst execute_action = (action_name, shape, params) => {\r\n    switch (action_name) {\r\n        case 'move':\r\n            shape.moveTo(params['x'], params['y']);\r\n            break;\r\n        case 'rotate':\r\n            shape.rotate(params['rotation']);\r\n            break;\r\n        case 'flip':\r\n            shape.flip(params['axis']);\r\n            break;\r\n        default:\r\n            console.log('Unknown action: ' + action_name);\r\n    }\r\n};\r\n\r\n/**\r\n *\r\n * @param {randomly selected shape} rand_shape\r\n * @param {one of ['move', 'rotate']} action_type\r\n * @param {copy of target shapes} shapes\r\n */\r\nconst generate_params = (rand_shape, action_type, grid_config) => {\r\n    var max = grid_config.board_size;\r\n    var min = 0;\r\n    var rotations = [90, 180, 270];\r\n    var axis = ['horizontal', 'vertical'];\r\n\r\n    switch (action_type) {\r\n        case 'move':\r\n            let rand_x = random_in_range(min, max, grid_config.block_size);\r\n            let rand_y = random_in_range(min, max, grid_config.block_size);\r\n            return { 'x': rand_x, 'y': rand_y };\r\n        case 'rotate':\r\n            let rand_angle = rotations[Math.floor(Math.random() * rotations.length)];\r\n            return { 'rotation': rand_angle };\r\n        case 'flip':\r\n            let rand_axis = axis[Math.floor(Math.random() * axis.length)];\r\n            return { 'axis': rand_axis };\r\n        default:\r\n            console.log('Not implemented: ' + action_type);\r\n            return;\r\n    }\r\n};\r\n\r\n/**\r\n * Retrieve random number rn with rn >= min and rn <= max\r\n *\r\n * @param {int} min\r\n * @param {int} max\r\n * @param {int} step\r\n */\r\nconst random_in_range = (min, max, step=1) => {\r\n    return (Math.floor(Math.random() * ((max - min)/step)) + min) * step\r\n};\r\n\r\n/**\r\n * Checks if action and shape are valid considering the current board state\r\n * @param {*} action_name\r\n * @param {*} shape\r\n * @param {*} params\r\n */\r\nconst isValidAction = (action_name, shape, pento_shapes, grid_config) => {\r\n    // make extra check for place as this is a one time action\r\n    if (shape.is_inside(grid_config.x, grid_config.y, grid_config.x+grid_config.board_size, grid_config.y+grid_config.board_size)) {\r\n        switch (action_name) {\r\n            case 'place':\r\n                if (!has_collisions(shape, pento_shapes)) {\r\n                    return true;\r\n                }\r\n                break;\r\n            case 'move':\r\n                if (!has_collisions(shape, pento_shapes) && !shape.has_connections()) {\r\n                    return true;\r\n                }\r\n                break;\r\n            case 'rotate':\r\n                if (!has_collisions(shape, pento_shapes) && !shape.has_connections()) {\r\n                    return true;\r\n                }\r\n                break;\r\n            case 'flip':\r\n                if (!has_collisions(shape, pento_shapes) && !shape.has_connections()) {\r\n                    return true;\r\n                }\r\n                break;\r\n        }\r\n    }\r\n    return false;\r\n};\r\n\r\n/**\r\n * Is true when at least one shape collides with this shape\r\n * @param {shape to check for} shape\r\n */\r\nconst has_collisions = (shape, pento_shapes) => {\r\n    return get_collisions(shape, pento_shapes).length > 0\r\n}\r\n\r\n/**\r\n * Returns a list of shapes colliding with shape\r\n * @param {shape to check for} shape\r\n */\r\nconst get_collisions = (shape, pento_shapes) => {\r\n    let hits = [];\r\n    for (let key in pento_shapes) {\r\n        let other_shape = pento_shapes[key];\r\n        if (other_shape.name != shape.name) {\r\n            if (shape.hits(other_shape)) {\r\n                hits.push(other_shape);\r\n            }\r\n        }\r\n    }\r\n    return hits;\r\n}","A:\\Teaching\\Interaktionsdesign für soziale Roboter\\PentominoWithFurhat\\assets\\pentomino\\src\\pento-objects\\HelperDrawingBoard.js",[],"A:\\Teaching\\Interaktionsdesign für soziale Roboter\\PentominoWithFurhat\\assets\\pentomino\\src\\pento-objects\\PentoBlock.js",["107","108","109","110","111","112","113","114","115","116","117","118"],"export class Block {\r\n    constructor(x, y, width, height, color) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.width = width;\r\n        this.height = height;\r\n        this.color = color;\r\n        this.border_color = 'black';\r\n        this.rotation = 0;\r\n\r\n        this.shape_center_x = 0;\r\n        this.shape_center_y = 0;\r\n\r\n        this.create_vertices();\r\n    }\r\n\r\n    get_x(){\r\n        return this._vertices[0][0]\r\n    }\r\n\r\n    get_y(){\r\n        return this._vertices[0][1]\r\n    }\r\n\r\n    get_center(){\r\n        var x_sum = 0;\r\n        var y_sum = 0;\r\n        for (var vertex_index in this._vertices) {\r\n            var vertex = this._vertices[vertex_index];\r\n            x_sum += vertex[0];\r\n            y_sum += vertex[1];\r\n        }\r\n        return [x_sum/this._vertices.length, y_sum/this._vertices.length]\r\n    }\r\n\r\n    set_shape_center(center_dx, center_dy) {\r\n        this.shape_center_x = center_dx || 0;\r\n        this.shape_center_y = center_dy || 0;\r\n    }\r\n\r\n    is_inside(bbox, offsetX, offsetY) {\r\n        for (var vertex_index in this._vertices) {\r\n            var vertex = this._vertices[vertex_index];\r\n            var point_x = vertex[0] + offsetX;\r\n            var point_y = vertex[1] + offsetY;\r\n            if (point_x < bbox[0] || point_x > bbox[0] + bbox[2] || point_y > bbox[1] + bbox[3] || point_y < bbox[1]) {\r\n                return false\r\n            }\r\n        }\r\n        return true\r\n    }\r\n\r\n    /**\r\n     * Returs a deepcopy of this block\r\n     */\r\n    copy() {\r\n        var block_copy = Block(this.x, this.y, this.width, this.height, this.color);\r\n        return block_copy\r\n    }\r\n\r\n    create_vertices() {\r\n        this._vertices = [\r\n            [this.x, this.y],\r\n            [this.x + this.width, this.y],\r\n            [this.x + this.width, this.y + this.height],\r\n            [this.x, this.y + this.height]\r\n        ];\r\n\r\n        this._edge_style = [0.5,0.5,0.5,0.5];\r\n    }\r\n\r\n    get_vertices(){\r\n        return this._vertices\r\n    }\r\n\r\n    get_edge_style(row){\r\n        return this._edge_style[row]\r\n    }\r\n\r\n    set_edge_style(row, style){\r\n        this._edge_style[row] = style;\r\n    }\r\n\r\n    get_vertex(row, col) {\r\n        return this._vertices[row][col]\r\n    }\r\n\r\n    set_vertex(row, col, value) {\r\n        this._vertices[row][col] = value;\r\n    }\r\n\r\n    _move(dx, dy) {\r\n        this.x += dx;\r\n        this.y += dy;\r\n        this._update_vertices(dx, dy);\r\n    }\r\n\r\n    _update_vertices(dx, dy) {\r\n        for (var i = 0; i < this._vertices.length; i++) {\r\n            var vertex = this._vertices[i];\r\n            vertex[0] += dx;\r\n            vertex[1] += dy;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Rotate the whole shape\r\n     * @param {Angle of rotation in degrees} angle\r\n     */\r\n    rotate(delta_angle, new_angle) {\r\n        // move to center\r\n        this._move(-this.shape_center_x, -this.shape_center_y);\r\n\r\n        // do rotation of vertices\r\n        for (var i = 0; i < this._vertices.length; i++) {\r\n            var vertex = this._vertices[i];\r\n            var x = vertex[0];\r\n            var y = vertex[1];\r\n            this.set_vertex(i, 0, Math.cos(delta_angle * Math.PI / 180) * x - Math.sin(delta_angle * Math.PI / 180) * y);\r\n            this.set_vertex(i, 1, Math.sin(delta_angle * Math.PI / 180) * x + Math.cos(delta_angle * Math.PI / 180) * y);\r\n        }\r\n\r\n        // move back to original position\r\n        this._move(this.shape_center_x, this.shape_center_y);\r\n\r\n        // store current rotation\r\n        this.rotation = new_angle;\r\n    }\r\n\r\n    /**\r\n     * Resizes the block and adapts its coordinates to match a new board size.\r\n     * @param {new size} block_size\r\n     * @param {new board size / old board size} pos_factor\r\n     */\r\n    scale(block_size, pos_factor) {\r\n        this.width = block_size;\r\n        this.height = block_size;\r\n        this.x *= pos_factor;\r\n        this.y *= pos_factor;\r\n    }\r\n\r\n    /**\r\n     * Calculates an overlap of two polygons using their vertices and the SAT method (Separating Axis Theorem)\r\n     * @param {block for comparison} block\r\n     * @param {delta of shapes x coord} dx\r\n     * @param {delta of shapes y coord} dy\r\n     */\r\n    hits(block, dx, dy) {\r\n        // create a copy of own vertices\r\n        var a = [];\r\n        for (var vi in this._vertices.slice()) {\r\n            a.push([this._vertices[vi][0] + 0, this._vertices[vi][1] + 0]);\r\n        }\r\n        var b = block._vertices.slice()\r\n\r\n        // apply delta of shapes positions\r\n        for (var i = 0; i < a.length; i++) {\r\n            var vertex = a[i];\r\n            vertex[0] += dx;\r\n            vertex[1] += dy;\r\n        }\r\n\r\n        var rectangles = [a, b];\r\n        var minA, maxA, projected, i, i1, j, minB, maxB;\r\n\r\n        for (i = 0; i < rectangles.length; i++) {\r\n\r\n            // for each polygon, look at each edge of the polygon, and determine if it separates\r\n            // the two shapes\r\n            var rectangle = rectangles[i];\r\n            for (i1 = 0; i1 < rectangle.length; i1++) {\r\n\r\n                // grab 2 vertices to create an edge\r\n                var i2 = (i1 + 1) % rectangle.length;\r\n                var p1 = rectangle[i1];\r\n                var p2 = rectangle[i2];\r\n\r\n                // find the line perpendicular to this edge\r\n                var normal = { x: p2[1] - p1[1], y: p1[0] - p2[0] };\r\n\r\n                minA = maxA = undefined;\r\n                // for each vertex in the first shape, project it onto the line perpendicular to the edge\r\n                // and keep track of the min and max of these values\r\n                for (j = 0; j < a.length; j++) {\r\n                    projected = normal.x * a[j][0] + normal.y * a[j][1];\r\n                    if (minA == undefined || projected < minA) {\r\n                        minA = projected;\r\n                    }\r\n                    if (maxA == undefined || projected > maxA) {\r\n                        maxA = projected;\r\n                    }\r\n                }\r\n\r\n                // for each vertex in the second shape, project it onto the line perpendicular to the edge\r\n                // and keep track of the min and max of these values\r\n                minB = maxB = undefined;\r\n                for (j = 0; j < b.length; j++) {\r\n                    projected = normal.x * b[j][0] + normal.y * b[j][1];\r\n                    if (minB == undefined || projected < minB) {\r\n                        minB = projected;\r\n                    }\r\n                    if (maxB == undefined || projected > maxB) {\r\n                        maxB = projected;\r\n                    }\r\n                }\r\n\r\n                // if there is no overlap between the projects, the edge we are looking at separates the two\r\n                // polygons, and we know there is no overlap\r\n                if (maxA < minB || maxB < minA) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Rotates the shape by angle. This implementation rearranges the blocks on the\r\n     * internal matrix. Only angles 90, -90, 180 and -180 are possible\r\n     * @param {turning angle, one of [90,-90,180,-180]} angle\r\n     * @param {true to log the action to the changes array} track\r\n     */\r\n    rotateByRearrange(delta_angle, new_angle) {\r\n        if (delta_angle == 90 || delta_angle == -270) {\r\n            // new x is (-1) * old y; new y is old x\r\n            this._move((-1) * this.y - this.x, this.x - this.y);\r\n        } else if (delta_angle == -90 || delta_angle == 270) {\r\n            // new x is old y; new y is (-1) * old x\r\n            this._move(this.y - this.x, (-1) * this.x  - this.y);\r\n        } else if (Math.abs(delta_angle) == 180) {\r\n            // new x is (-1) * old x; new y is (-1) * old y\r\n            this._move((-1) * this.x - this.x, (-1) * this.y - this.y);\r\n        } else {\r\n            console.log(`Angle ${delta_angle} not applicable to method rotateByRearrange. ` +\r\n                'Only angles [90,-90,180,-180] allowed, use method rotate otherwise');\r\n            return;\r\n        }\r\n        // store current rotation\r\n        this.rotation = new_angle;\r\n    }\r\n\r\n    /**\r\n     * Moves the block to perform a shape flip\r\n     * @param {reflection axis: one of [horizontal, vertical]} axis\r\n     */\r\n    flip(axis) {\r\n        if (axis == 'horizontal') {\r\n            this._move(0, (-2) * this.y);\r\n        } else if (axis == 'vertical') {\r\n            this._move((-2) * this.x, 0);\r\n        } else {\r\n            console.log(`Unknown axis: ${axis} at PentoBlock.flip(). `+\r\n                'Options: [horizontal, vertical');\r\n        }\r\n    }\r\n\r\n\r\n\r\n};","A:\\Teaching\\Interaktionsdesign für soziale Roboter\\PentominoWithFurhat\\assets\\pentomino\\src\\pento-objects\\HelperDrawingBlocks.js",["119"],"export const draw_border = (ctx, block, offsetX, offsetY) => {\r\n\r\n    var start_x = block.get_x() + offsetX;\r\n    var start_y = block.get_y() + offsetY;\r\n\r\n    for (var row = 1; row <= block.get_vertices().length; row++) {\r\n        ctx.beginPath();\r\n        ctx.moveTo(start_x, start_y);\r\n        var row_index = row < block.get_vertices().length ? row: 0;\r\n\r\n\r\n        ctx.lineWidth = block.get_edge_style(row_index);\r\n        ctx.strokeStyle = block.get_edge_style(row_index)==1? 'gray': block.border_color;\r\n\r\n        var to_x = block.get_vertex(row_index, 0) + offsetX;\r\n        var to_y = block.get_vertex(row_index, 1) + offsetY;\r\n        ctx.lineTo(to_x, to_y);\r\n\r\n        ctx.stroke();\r\n        ctx.closePath();\r\n\r\n        start_x = block.get_vertex(row_index, 0) + offsetX;\r\n        start_y = block.get_vertex(row_index, 1) + offsetY;\r\n    }\r\n}\r\n\r\nexport const draw_shape_border = (ctx, shape, params) => {\r\n    // Draw blocks\r\n    for (var i = 0; i < shape.get_blocks().length; i++) {\r\n        var block = shape.get_blocks()[i];\r\n        draw_border(ctx, block, shape.x + params.offsetX, shape.y + params.offsetY);\r\n    }\r\n}\r\n\r\nexport const draw_shape = (ctx, shape, params) => {\r\n    ctx.beginPath();\r\n    // Draw blocks\r\n    for (var i = 0; i < shape.get_blocks().length; i++) {\r\n        var block = shape.get_blocks()[i];\r\n        draw_block(ctx, block, shape.x + params.offsetX, shape.y + params.offsetY, shape.is_active(), shape.highlight);\r\n    }\r\n}\r\n\r\nexport const draw_line = (ctx, block, row, offsetX, offsetY) => {\r\n    var to_x = block.get_vertex(row, 0) + offsetX;\r\n    var to_y = block.get_vertex(row, 1) + offsetY;\r\n    ctx.lineTo(to_x, to_y);\r\n}\r\n\r\nexport const draw_block = (ctx, block, offsetX, offsetY, active, highlight=null) => {\r\n    if (active) {\r\n        ctx.shadowColor = 'grey';\r\n        ctx.shadowBlur = 10;\r\n    } else if (highlight) {\r\n        ctx.shadowColor = highlight;\r\n        ctx.shadowBlur = 10;\r\n    } else {\r\n        ctx.shadowBlur = 0; // set highlight invisible\r\n    }\r\n    ctx.fillStyle = block.color;\r\n    ctx.strokeStyle = 'lightgray';\r\n    ctx.lineWidth = 1;\r\n    ctx.moveTo(block.get_vertex(0, 0) + offsetX, block.get_vertex(0, 1) + offsetY);\r\n\r\n    for (var row = 1; row <= block.get_vertices().length; row++) {\r\n        draw_line(ctx, block, row < block.get_vertices().length ? row : 0, offsetX, offsetY);\r\n    }\r\n    ctx.fill();\r\n};","A:\\Teaching\\Interaktionsdesign für soziale Roboter\\PentominoWithFurhat\\assets\\pentomino\\src\\pento-objects\\PentoShape.js",["120","121","122","123","124","125","126","127","128","129","130","131","132","133","134","135","136"],"import {pento_create_shape} from \"./HelperPentoShapes\";\r\n\r\nexport class Shape {\r\n    constructor(id, type, color, is_mirrored, rotation, block_size) {\r\n        this.id = id;\r\n        this.x = 0;\r\n        this.y = 0;\r\n        this.type = type;\r\n        this.color = color;\r\n        this.rotation = rotation;\r\n        this.is_mirrored = is_mirrored || false;\r\n        this.writable = true;\r\n        this.active = false;\r\n        this.highlight = false;\r\n\r\n        // shape internal grid and bounding box\r\n        this._internal_grid_size = [5, 5];\r\n        this._internal_grid_shifts = [2, 2];\r\n        this._internal_grid = [];\r\n        this._init_grid();\r\n\r\n        // log changes for rollback\r\n        this.changes = [];\r\n\r\n        // generate name\r\n        this.name = this.type + this.id + this.color;\r\n        this.blocks = [];\r\n        this.block_size = block_size;\r\n\r\n        // conntected shapes\r\n        this.connected = [];\r\n    }\r\n\r\n    /**\r\n     * Returns true if the shape is currently\r\n     * active and can be modified\r\n     */\r\n    is_active() {\r\n        return this.active\r\n    }\r\n\r\n    set_active() {\r\n        this.active = true;\r\n    }\r\n\r\n    set_deactive() {\r\n        this.active = false;\r\n    }\r\n\r\n    /**\r\n     * Toggle colored hightlighting of shape on and off\r\n     * @param {highlight color} color\r\n     */\r\n    set_highlight(color) {\r\n        this.highlight = color;\r\n    }\r\n\r\n    remove_highlight() {\r\n        this.highlight = null;\r\n    }\r\n\r\n    /**\r\n     * Checks whether the shape is inside the bounding box or has overlaps (returns false if any part of the shape is\r\n     * outside the bounding box)\r\n     * @param {Bound Box x} bb_x\r\n     * @param {Bounding Box y} bb_y\r\n     * @param {Bounding Box Width} bb_width\r\n     * @param {Bounding Box Height} bb_height\r\n     */\r\n    is_inside(bb_x, bb_y, bb_width, bb_height) {\r\n        var bounding_box = [bb_x, bb_y, bb_width, bb_height];\r\n        for (var block_index in this.blocks) {\r\n            var block = this.blocks[block_index];\r\n            if (!block.is_inside(bounding_box, this.x, this.y)) {\r\n                return false\r\n            }\r\n        }\r\n        return true\r\n    }\r\n\r\n    /**\r\n     * Returns (x,y) position\r\n     */\r\n    get_coords() {\r\n        return [this.x, this.y]\r\n    }\r\n\r\n    /**\r\n     * Checks whether these shapes are connected\r\n     * @param {shape} other_shape\r\n     */\r\n    is_connected(other_shape) {\r\n        return this.connected.indexOf(other_shape.name) != -1\r\n    }\r\n\r\n    /**\r\n     * Checks whether this shape is connected to any other\r\n     * shape\r\n     */\r\n    has_connections() {\r\n        return this.connected.length > 0\r\n    }\r\n\r\n    /**\r\n     * Return the internal grid matrix\r\n     */\r\n    get_internal_grid() {\r\n        return this._internal_grid\r\n    }\r\n\r\n    /**\r\n     * Return width of shape (number of horizontal blocks)\r\n     */\r\n    get_grid_width() {\r\n        return this._internal_grid_size[0]\r\n    }\r\n\r\n    /**\r\n     * Return height of shape (number of vertical blocks)\r\n     */\r\n    get_grid_height() {\r\n        return this._internal_grid_size[1]\r\n    }\r\n\r\n    /**\r\n     * Estimates the relative position of the\r\n     * other shape compared to this shape and\r\n     * returns a direction of connection\r\n     * @param {shape to connect to} other_shape\r\n     */\r\n    get_direction(other_shape) {\r\n        var delta_x = other_shape.x - this.x;\r\n        var delta_y = other_shape.y - this.y;\r\n        var directions = ['top', 'left', 'bottom', 'right'];\r\n\r\n        // select direction based on relative position difference\r\n        if (delta_x >= 0 && delta_y <= 0) {\r\n            return directions[0]\r\n        } else if (delta_x <= 0 && delta_y >= 0) {\r\n            return directions[1]\r\n        } else if (delta_x >= 0 && delta_y >= 0) {\r\n            return directions[2]\r\n        } else {\r\n            return directions[3]\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Copy matrix\r\n     * @param {Creates a deepcopy of a matrix} matrix\r\n     */\r\n    copy_matrix(matrix) {\r\n        var new_matrix = [];\r\n        for (var i = 0; i < matrix.length; i++) {\r\n            var row = [];\r\n            for (var e = 0; e < matrix[i].length; e++) {\r\n                row.push(matrix[i][e]);\r\n            }\r\n            new_matrix.push(row);\r\n        }\r\n        return new_matrix\r\n    }\r\n\r\n\r\n    /**\r\n     * Copy and rotate matrix 90 degrees clockwise\r\n     * @param {*} matrix\r\n     */\r\n    copy_and_rotate(matrix) {\r\n        // copy\r\n        var a = this.copy_matrix(matrix);\r\n\r\n        // rotate\r\n        var N = a.length;\r\n        for (var i = 0; i < (N / 2 | 0); i++) {\r\n            for (var j = i; j < N - i - 1; j++) {\r\n                var temp = a[i][j];\r\n                a[i][j] = a[N - 1 - j][i];\r\n                a[N - 1 - j][i] = a[N - 1 - i][N - 1 - j];\r\n                a[N - 1 - i][N - 1 - j] = a[j][N - 1 - i];\r\n                a[j][N - 1 - i] = temp;\r\n            }\r\n        }\r\n        return a\r\n    }\r\n\r\n    /**\r\n     * Returns the index of the first blocking column\r\n     * from the right\r\n     * @param {internal matrix} matrix\r\n     */\r\n    get_right_fbc(matrix) {\r\n        for (var i = matrix.length - 1; i >= 0; i--) {\r\n            if (matrix[i].indexOf(1) != -1)\r\n                break;\r\n        }\r\n        return i\r\n    }\r\n\r\n    /**\r\n     * Retrieves the index of the first blocking column\r\n     * from the left\r\n     * @param {internal matrix} matrix\r\n     */\r\n    get_left_fbc(matrix) {\r\n        for (var i = 0; i < matrix.length; i++) {\r\n            if (matrix[i].indexOf(1) != -1)\r\n                break;\r\n        }\r\n        return i\r\n    }\r\n\r\n    get_movement(look_left, fbc, fbc2, matrix) {\r\n        return [0, 0]\r\n    }\r\n\r\n    /**\r\n     * Connects to shapes\r\n     * @param {shape to connect to} other_shape\r\n     * @param {direction of connection} direction\r\n     */\r\n    align_and_connect(other_shape, direction) {\r\n        // get copy of matrix for inplace operations and rotate if necessary\r\n        if (direction == 'top' || direction == 'bottom') {\r\n            var matrix = this.copy_and_rotate(other_shape.get_internal_grid());\r\n        } else {\r\n            var matrix = this.copy_matrix(other_shape.get_internal_grid());\r\n        }\r\n\r\n        // index of left or right first blocking column respectively\r\n        var look_left = (direction == 'top' || direction == 'right');\r\n        var fbc = look_left ? this.get_right_fbc(matrix) : this.get_left_fbc(matrix);\r\n        var fbc2 = look_left ? this.get_left_fbc(matrix) : this.get_right_fbc(matrix);\r\n\r\n        // move other shape to new position\r\n        var new_positions = this.get_movement(look_left, fbc, fbc2, matrix);\r\n        other_shape.moveTo(new_positions[0], new_positions[1]);\r\n    }\r\n\r\n    connect_to(other_shape) {\r\n        // align internal grids\r\n        other_shape.rotate(this.rotation - other_shape.rotation);\r\n\r\n        // connect grids so that the resulting matrix doesnt contain a two (after adding both together)\r\n        // move shapes close together\r\n        //var direction = this.get_direction(other_shape)\r\n        //this.align_and_connect(other_shape, direction)\r\n\r\n        // register connection\r\n        //this.connected.push(other_shape.name)\r\n        //other_shape.connected.push(this.name)\r\n\r\n        return 'group' + this.id + other_shape.id\r\n    }\r\n\r\n    /**\r\n     * Creates the datastructure for the internal grid\r\n     */\r\n    _init_grid() {\r\n        for (var i = 0; i < this._internal_grid_size[0]; i++) {\r\n            this._internal_grid.push([]);\r\n            for (var e = 0; e < this._internal_grid_size[1]; e++) {\r\n                this._internal_grid[i].push(0);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the value at (row, col)\r\n     * @param {row} row\r\n     * @param {col} col\r\n     * @param {value for cell} value\r\n     */\r\n    _set_grid_value(row, col, value) {\r\n        //console.log(this._internal_grid)\r\n        //console.log(row)\r\n        this._internal_grid[row][col] = value;\r\n    }\r\n\r\n    /**\r\n     * Marks the position of a block on the internal grid with 1\r\n     * @param {x} block_x\r\n     * @param {y} block_y\r\n     */\r\n    _update_grid(block_x, block_y) {\r\n        var row = (block_y / this.block_size) + this._internal_grid_shifts[1];\r\n        var col = (block_x / this.block_size) + this._internal_grid_shifts[0];\r\n        this._set_grid_value(row, col, 1);\r\n    }\r\n\r\n    /**\r\n     * Rolls back N steps of modifications done to the shape (except initial placement)\r\n     * @param {int} steps\r\n     */\r\n    rollback(steps) {\r\n        if (this.changes.length > 0) {\r\n            for (var i = (this.changes.length - 1); i >= Math.max(0, this.changes.length - steps); i--) {\r\n                this.undo_action(this.changes[i]);\r\n            }\r\n            this.changes = this.changes.slice(0, Math.max(0, this.changes.length - steps));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Restores the state of the shape before the modification\r\n     * @param {action object} action\r\n     */\r\n    undo_action(action) {\r\n        switch (action['name']) {\r\n            case 'move':\r\n                this.moveTo(action['x'], action['y'], false);\r\n                break;\r\n            case 'rotate':\r\n                this.rotate(360 - action['angle'], false);\r\n                break;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the true angle for rotation\r\n     * @param {degree} angle\r\n     */\r\n    _get_true_angle(angle) {\r\n        var true_angle = (this.rotation + angle) % 360;\r\n        return true_angle\r\n    }\r\n\r\n    /**\r\n     * Helper that updates the rotation of internal block model\r\n     */\r\n    _rotate_blocks(delta_angle) {\r\n        for (var i = 0; i < this.get_blocks().length; i++) {\r\n            var block = this.get_blocks()[i];\r\n            block.rotate(delta_angle, this.rotation);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Rotates the shape by angle\r\n     * @param {difference to current angle in degrees} angle\r\n     */\r\n    rotate(angle) {\r\n        if (angle == 0) { return; }\r\n\r\n        this.rotation = this._get_true_angle(angle);\r\n        // use rearrange method if possible\r\n        if (angle % 90 == 0) {\r\n            this.rotateByRearrange(angle);\r\n        } else {\r\n            this._rotate_blocks(angle);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates the block edge styles.\r\n     * To be used after rearranging blocks so that the black outline still\r\n     * matches the shape formation.\r\n     */\r\n    _update_outline() {\r\n        for (var i = 0; i < this.get_blocks().length; i++) {\r\n            var block = this.get_blocks()[i];\r\n            var adjacent_blocks = this.get_adjacent_blocks(block.get_x(), block.get_y());\r\n            for (var a = 0; a < adjacent_blocks.length; a++) {\r\n                if (adjacent_blocks[a] == 0) {\r\n                    block.set_edge_style(a, 2);\r\n                } else {\r\n                    block.set_edge_style(a, 0.5);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Rotates the shape by angle. This implementation rearranges the blocks on the\r\n     * internal matrix. Only angles 90, -90, 180 and -180 are possible\r\n     * @param {turning angle, one of [90,-90,180,-180]} angle\r\n     * @param {true to log the action to the changes array} track\r\n     */\r\n    rotateByRearrange(angle, track) {\r\n        if (track != false) {\r\n            this.changes.push({ 'name': 'rotate', 'angle': angle });\r\n        }\r\n        this.rotation = this._get_true_angle(angle);\r\n        // empty the grid (since the blocks will be rearranged)\r\n        this._empty_grid();\r\n        for (var i = 0; i < this.get_blocks().length; i++) {\r\n            var block = this.get_blocks()[i];\r\n            block.rotateByRearrange(angle, this.rotation);\r\n            // update the internal grid\r\n            this._update_grid(block.get_x(), block.get_y());\r\n        }\r\n        // redraw the outline\r\n        this._update_outline();\r\n    }\r\n\r\n    /**\r\n     * Flips the shape by rearranging the blocks\r\n     * @param {one of ['horizontal', 'vertical']} axis\r\n     * @param {true to log the action to the changes array} track\r\n     */\r\n    flip(axis, track) {\r\n        if (track != false) {\r\n            this.changes.push({ 'name': 'flip', 'axis': axis});\r\n        }\r\n        // empty grid (since blocks will be rearranged)\r\n        this._empty_grid()\r\n        for (var i = 0; i < this.get_blocks().length; i++) {\r\n            var block = this.get_blocks()[i];\r\n            block.flip(axis);\r\n            this._update_grid(block.get_x(), block.get_y());\r\n        }\r\n        // redraw the black outline after block rearrangement\r\n        this._update_outline();\r\n        this.is_mirrored = !this.is_mirrored;\r\n    }\r\n\r\n    /**\r\n     * Moves shape to a fixed position\r\n     * @param {x} x\r\n     * @param {y} y\r\n     * @param {if this action should be tracked (can't be undone otherwise)} track\r\n     */\r\n    moveTo(x, y, track) {\r\n        if (track != false) {\r\n            this.changes.push({ 'name': 'move', 'x': this.x, 'y': this.y});\r\n        }\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n\r\n    /**\r\n     * Open for changes\r\n     */\r\n    open() {\r\n        this.writable = true;\r\n    }\r\n\r\n    /**\r\n     * Finalizes the shape\r\n     * No further modifications are allowed after\r\n     * this function is called\r\n     */\r\n    close() {\r\n        this.writable = false;\r\n\r\n        var x_sum = 0;\r\n        var y_sum = 0;\r\n\r\n//\t\t\tfor (var block_index in this.blocks) {\r\n//\t\t\t\tvar block_center = this.blocks[block_index].get_center();\r\n//\t\t\t\tx_sum += block_center[0];\r\n//\t\t\t\ty_sum += block_center[1];\r\n//\t\t\t}\r\n//\t\t\t// this leads to nice turning, but doesn't align shape with grid\r\n//\t\t\tvar center_x = x_sum / this.blocks.length;\r\n//\t\t\tvar center_y = y_sum / this.blocks.length;\r\n        var center_x = 20;\r\n        var center_y = 20;\r\n\r\n        // update blocks\r\n        for (var block_index in this.blocks) {\r\n            var block = this.blocks[block_index];\r\n            block.set_shape_center(center_x, center_y);\r\n\r\n            // update block styles\r\n            var adjacent_blocks = this.get_adjacent_blocks(block.get_x(), block.get_y());\r\n            for (var i = 0; i < adjacent_blocks.length; i++) {\r\n                if (adjacent_blocks[i] === 0) {\r\n                    block.set_edge_style(i, 2);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Retrieve a matrix (top, right, bottom, left) which represents\r\n     * adjacent blocks with 1 (0 if no block is adjacent on a side)\r\n     * @param {block x} x\r\n     * @param {block y} y\r\n     */\r\n    get_adjacent_blocks(x, y) {\r\n        var row = Math.round(y / this.block_size) + this._internal_grid_shifts[1];\r\n        var col = Math.round(x / this.block_size) + this._internal_grid_shifts[0];\r\n        var adjacent_matrix = [0,0,0,0];\r\n        // top\r\n        if (row - 1 >= 0) {\r\n            adjacent_matrix[1] = this._internal_grid[row - 1][col];\r\n        }\r\n\r\n        // right\r\n        if (col + 1 < this._internal_grid[row].length) {\r\n            adjacent_matrix[2] = this._internal_grid[row][col + 1];\r\n        }\r\n\r\n        // bottom\r\n        if (row + 1 < this._internal_grid.length) {\r\n            adjacent_matrix[3] = this._internal_grid[row + 1][col];\r\n        }\r\n\r\n        // left\r\n        if (col - 1 >= 0) {\r\n            adjacent_matrix[0] = this._internal_grid[row][col - 1];\r\n        }\r\n\r\n        return adjacent_matrix\r\n    }\r\n\r\n    /**\r\n     * Adds a block to the shape if it's writable\r\n     * @param {block object} block\r\n     */\r\n    add_block(block) {\r\n        if (this.writable) {\r\n            this.blocks.push(block);\r\n            this._update_grid(block.x, block.y);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns all blocks of the shape\r\n     */\r\n    get_blocks() {\r\n        return this.blocks\r\n    }\r\n\r\n    /**\r\n     * Checks whether the shapes hit each other\r\n     * @param {shape to compare} other_shape\r\n     */\r\n    hits(other_shape) {\r\n        // calculate delta between shapes\r\n        var dx = this.x - other_shape.x;\r\n        var dy = this.y - other_shape.y;\r\n\r\n        for (var index in this.blocks) {\r\n            var current_block = this.blocks[index];\r\n            var other_blocks = other_shape.get_blocks();\r\n\r\n            for (var o_index in other_blocks) {\r\n                var other_block = other_blocks[o_index];\r\n                if (current_block.hits(other_block, dx, dy)) {\r\n                    return true\r\n                }\r\n            }\r\n        }\r\n        return false\r\n    }\r\n\r\n    /**\r\n     * Returns a deep copy of the shape with the new id assigned\r\n     * @param {id} new_id\r\n     */\r\n    copy(new_id) {\r\n        var shape_copy = pento_create_shape(new_id, this.x, this.y, this.type, this.color,\r\n            this.is_mirrored, this.rotation, this.block_size);\r\n        shape_copy.width = this.width;\r\n        shape_copy.height = this.height;\r\n        return shape_copy\r\n    }\r\n\r\n    /**\r\n     * Adapts the shape's coordinates to a differently sized board.\r\n     * @param {new block size} block_size\r\n     * @param {new board size / old board size} pos_factor\r\n     */\r\n    scale(block_size, pos_factor) {\r\n        // change block sizes\r\n        this.block_size = block_size;\r\n        // scale coordinates\r\n        this.x *= pos_factor;\r\n        this.y *= pos_factor;\r\n        // scale each block\r\n        var blocks = [];\r\n        for (var b of this.get_blocks()) {\r\n            blocks.push(new document.Block(\tb.x * pos_factor,\r\n                b.y * pos_factor,\r\n                block_size,\r\n                block_size,\r\n                b.color));\r\n        }\r\n        this.blocks = blocks;\r\n    }\r\n\r\n    /**\r\n     * Fills the internal grid with zeros, i.e. deletes all block markers\r\n     */\r\n    _empty_grid() {\r\n        for (var x = 0; x < this._internal_grid_size[0]; x++) {\r\n            for (var y = 0; y < this._internal_grid_size[1]; y++) {\r\n                this._set_grid_value(x, y, 0);\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n\r\n    toString() {\r\n        return this.name\r\n    }\r\n};\r\n",{"ruleId":"137","severity":1,"message":"138","line":6,"column":10,"nodeType":"139","messageId":"140","endLine":6,"endColumn":17},{"ruleId":"137","severity":1,"message":"141","line":52,"column":10,"nodeType":"139","messageId":"140","endLine":52,"endColumn":21},{"ruleId":"142","severity":1,"message":"143","line":66,"column":27,"nodeType":"144","messageId":"145","endLine":71,"endColumn":8},{"ruleId":"146","severity":1,"message":"147","line":141,"column":55,"nodeType":"148","messageId":"149","endLine":141,"endColumn":57},{"ruleId":"146","severity":1,"message":"147","line":144,"column":61,"nodeType":"148","messageId":"149","endLine":144,"endColumn":63},{"ruleId":"146","severity":1,"message":"147","line":177,"column":21,"nodeType":"148","messageId":"149","endLine":177,"endColumn":23},{"ruleId":"150","severity":1,"message":"151","line":218,"column":6,"nodeType":"152","endLine":218,"endColumn":29,"suggestions":"153"},{"ruleId":"150","severity":1,"message":"154","line":261,"column":6,"nodeType":"152","endLine":261,"endColumn":8,"suggestions":"155"},{"ruleId":"150","severity":1,"message":"156","line":276,"column":6,"nodeType":"152","endLine":276,"endColumn":8,"suggestions":"157"},{"ruleId":"158","severity":1,"message":"159","line":50,"column":13,"nodeType":"139","messageId":"160","endLine":50,"endColumn":18},{"ruleId":"158","severity":1,"message":"159","line":52,"column":13,"nodeType":"139","messageId":"160","endLine":52,"endColumn":18},{"ruleId":"158","severity":1,"message":"161","line":66,"column":14,"nodeType":"139","messageId":"160","endLine":66,"endColumn":15},{"ruleId":"158","severity":1,"message":"159","line":68,"column":17,"nodeType":"139","messageId":"160","endLine":68,"endColumn":22},{"ruleId":"158","severity":1,"message":"159","line":70,"column":17,"nodeType":"139","messageId":"160","endLine":70,"endColumn":22},{"ruleId":"158","severity":1,"message":"161","line":85,"column":14,"nodeType":"139","messageId":"160","endLine":85,"endColumn":15},{"ruleId":"158","severity":1,"message":"159","line":87,"column":17,"nodeType":"139","messageId":"160","endLine":87,"endColumn":22},{"ruleId":"158","severity":1,"message":"159","line":89,"column":17,"nodeType":"139","messageId":"160","endLine":89,"endColumn":22},{"ruleId":"158","severity":1,"message":"159","line":115,"column":9,"nodeType":"139","messageId":"160","endLine":115,"endColumn":14},{"ruleId":"158","severity":1,"message":"159","line":118,"column":9,"nodeType":"139","messageId":"160","endLine":118,"endColumn":14},{"ruleId":"158","severity":1,"message":"159","line":131,"column":13,"nodeType":"139","messageId":"160","endLine":131,"endColumn":18},{"ruleId":"158","severity":1,"message":"161","line":145,"column":14,"nodeType":"139","messageId":"160","endLine":145,"endColumn":15},{"ruleId":"158","severity":1,"message":"159","line":146,"column":13,"nodeType":"139","messageId":"160","endLine":146,"endColumn":18},{"ruleId":"158","severity":1,"message":"159","line":150,"column":9,"nodeType":"139","messageId":"160","endLine":150,"endColumn":14},{"ruleId":"158","severity":1,"message":"159","line":175,"column":13,"nodeType":"139","messageId":"160","endLine":175,"endColumn":18},{"ruleId":"158","severity":1,"message":"159","line":177,"column":13,"nodeType":"139","messageId":"160","endLine":177,"endColumn":18},{"ruleId":"137","severity":1,"message":"162","line":1,"column":16,"nodeType":"139","messageId":"140","endLine":1,"endColumn":25},{"ruleId":"137","severity":1,"message":"163","line":2,"column":9,"nodeType":"139","messageId":"140","endLine":2,"endColumn":27},{"ruleId":"137","severity":1,"message":"164","line":9,"column":11,"nodeType":"139","messageId":"140","endLine":9,"endColumn":16},{"ruleId":"137","severity":1,"message":"165","line":10,"column":11,"nodeType":"139","messageId":"140","endLine":10,"endColumn":23},{"ruleId":"137","severity":1,"message":"166","line":26,"column":11,"nodeType":"139","messageId":"140","endLine":26,"endColumn":26},{"ruleId":"137","severity":1,"message":"167","line":27,"column":11,"nodeType":"139","messageId":"140","endLine":27,"endColumn":29},{"ruleId":"137","severity":1,"message":"168","line":28,"column":11,"nodeType":"139","messageId":"140","endLine":28,"endColumn":34},{"ruleId":"137","severity":1,"message":"169","line":29,"column":9,"nodeType":"139","messageId":"140","endLine":29,"endColumn":27},{"ruleId":"137","severity":1,"message":"170","line":31,"column":11,"nodeType":"139","messageId":"140","endLine":31,"endColumn":31},{"ruleId":"137","severity":1,"message":"171","line":32,"column":11,"nodeType":"139","messageId":"140","endLine":32,"endColumn":36},{"ruleId":"146","severity":1,"message":"172","line":39,"column":48,"nodeType":"148","messageId":"149","endLine":39,"endColumn":50},{"ruleId":"158","severity":1,"message":"173","line":79,"column":22,"nodeType":"139","messageId":"160","endLine":79,"endColumn":23},{"ruleId":"146","severity":1,"message":"147","line":88,"column":18,"nodeType":"148","messageId":"149","endLine":88,"endColumn":20},{"ruleId":"137","severity":1,"message":"174","line":101,"column":11,"nodeType":"139","messageId":"140","endLine":101,"endColumn":20},{"ruleId":"137","severity":1,"message":"175","line":105,"column":11,"nodeType":"139","messageId":"140","endLine":105,"endColumn":21},{"ruleId":"137","severity":1,"message":"176","line":109,"column":11,"nodeType":"139","messageId":"140","endLine":109,"endColumn":21},{"ruleId":"137","severity":1,"message":"177","line":113,"column":11,"nodeType":"139","messageId":"140","endLine":113,"endColumn":21},{"ruleId":"137","severity":1,"message":"178","line":117,"column":11,"nodeType":"139","messageId":"140","endLine":117,"endColumn":21},{"ruleId":"137","severity":1,"message":"179","line":121,"column":11,"nodeType":"139","messageId":"140","endLine":121,"endColumn":22},{"ruleId":"137","severity":1,"message":"180","line":128,"column":11,"nodeType":"139","messageId":"140","endLine":128,"endColumn":20},{"ruleId":"137","severity":1,"message":"181","line":135,"column":11,"nodeType":"139","messageId":"140","endLine":135,"endColumn":27},{"ruleId":"150","severity":1,"message":"182","line":158,"column":8,"nodeType":"152","endLine":158,"endColumn":29,"suggestions":"183"},{"ruleId":"137","severity":1,"message":"184","line":40,"column":11,"nodeType":"139","messageId":"140","endLine":40,"endColumn":18},{"ruleId":"137","severity":1,"message":"185","line":41,"column":11,"nodeType":"139","messageId":"140","endLine":41,"endColumn":15},{"ruleId":"137","severity":1,"message":"186","line":50,"column":11,"nodeType":"139","messageId":"140","endLine":50,"endColumn":23},{"ruleId":"146","severity":1,"message":"147","line":108,"column":28,"nodeType":"148","messageId":"149","endLine":108,"endColumn":30},{"ruleId":"137","severity":1,"message":"187","line":125,"column":23,"nodeType":"139","messageId":"140","endLine":125,"endColumn":37},{"ruleId":"188","severity":1,"message":"189","line":197,"column":9,"nodeType":"190","messageId":"191","endLine":218,"endColumn":10},{"ruleId":"146","severity":1,"message":"172","line":239,"column":30,"nodeType":"148","messageId":"149","endLine":239,"endColumn":32},{"ruleId":"158","severity":1,"message":"173","line":164,"column":36,"nodeType":"139","messageId":"160","endLine":164,"endColumn":37},{"ruleId":"146","severity":1,"message":"147","line":186,"column":30,"nodeType":"148","messageId":"149","endLine":186,"endColumn":32},{"ruleId":"146","severity":1,"message":"147","line":189,"column":30,"nodeType":"148","messageId":"149","endLine":189,"endColumn":32},{"ruleId":"146","severity":1,"message":"147","line":199,"column":30,"nodeType":"148","messageId":"149","endLine":199,"endColumn":32},{"ruleId":"146","severity":1,"message":"147","line":202,"column":30,"nodeType":"148","messageId":"149","endLine":202,"endColumn":32},{"ruleId":"146","severity":1,"message":"147","line":224,"column":25,"nodeType":"148","messageId":"149","endLine":224,"endColumn":27},{"ruleId":"146","severity":1,"message":"147","line":224,"column":46,"nodeType":"148","messageId":"149","endLine":224,"endColumn":48},{"ruleId":"146","severity":1,"message":"147","line":227,"column":32,"nodeType":"148","messageId":"149","endLine":227,"endColumn":34},{"ruleId":"146","severity":1,"message":"147","line":227,"column":54,"nodeType":"148","messageId":"149","endLine":227,"endColumn":56},{"ruleId":"146","severity":1,"message":"147","line":230,"column":42,"nodeType":"148","messageId":"149","endLine":230,"endColumn":44},{"ruleId":"146","severity":1,"message":"147","line":247,"column":18,"nodeType":"148","messageId":"149","endLine":247,"endColumn":20},{"ruleId":"146","severity":1,"message":"147","line":249,"column":25,"nodeType":"148","messageId":"149","endLine":249,"endColumn":27},{"ruleId":"146","severity":1,"message":"147","line":13,"column":58,"nodeType":"148","messageId":"149","endLine":13,"endColumn":60},{"ruleId":"146","severity":1,"message":"172","line":93,"column":57,"nodeType":"148","messageId":"149","endLine":93,"endColumn":59},{"ruleId":"146","severity":1,"message":"172","line":194,"column":38,"nodeType":"148","messageId":"149","endLine":194,"endColumn":40},{"ruleId":"146","severity":1,"message":"172","line":207,"column":38,"nodeType":"148","messageId":"149","endLine":207,"endColumn":40},{"ruleId":"146","severity":1,"message":"147","line":224,"column":23,"nodeType":"148","messageId":"149","endLine":224,"endColumn":25},{"ruleId":"146","severity":1,"message":"147","line":224,"column":45,"nodeType":"148","messageId":"149","endLine":224,"endColumn":47},{"ruleId":"158","severity":1,"message":"192","line":227,"column":17,"nodeType":"139","messageId":"160","endLine":227,"endColumn":23},{"ruleId":"146","severity":1,"message":"147","line":231,"column":36,"nodeType":"148","messageId":"149","endLine":231,"endColumn":38},{"ruleId":"146","severity":1,"message":"147","line":231,"column":58,"nodeType":"148","messageId":"149","endLine":231,"endColumn":60},{"ruleId":"188","severity":1,"message":"189","line":309,"column":9,"nodeType":"190","messageId":"191","endLine":316,"endColumn":10},{"ruleId":"146","severity":1,"message":"147","line":343,"column":19,"nodeType":"148","messageId":"149","endLine":343,"endColumn":21},{"ruleId":"146","severity":1,"message":"147","line":347,"column":24,"nodeType":"148","messageId":"149","endLine":347,"endColumn":26},{"ruleId":"146","severity":1,"message":"147","line":364,"column":40,"nodeType":"148","messageId":"149","endLine":364,"endColumn":42},{"ruleId":"146","severity":1,"message":"172","line":380,"column":19,"nodeType":"148","messageId":"149","endLine":380,"endColumn":21},{"ruleId":"146","severity":1,"message":"172","line":402,"column":19,"nodeType":"148","messageId":"149","endLine":402,"endColumn":21},{"ruleId":"146","severity":1,"message":"172","line":424,"column":19,"nodeType":"148","messageId":"149","endLine":424,"endColumn":21},{"ruleId":"137","severity":1,"message":"193","line":446,"column":13,"nodeType":"139","messageId":"140","endLine":446,"endColumn":18},{"ruleId":"137","severity":1,"message":"194","line":447,"column":13,"nodeType":"139","messageId":"140","endLine":447,"endColumn":18},"no-unused-vars","'pento_I' is defined but never used.","Identifier","unusedVar","'initialized' is assigned a value but never used.","no-lone-blocks","Block is redundant.","BlockStatement","redundantBlock","eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","react-hooks/exhaustive-deps","React Hook useEffect has missing dependencies: 'initialShapes', 'pentoPieceToObj', and 'sendDataToFurhat'. Either include them or remove the dependency array.","ArrayExpression",["195"],"React Hook useEffect has missing dependencies: 'placeSelected', 'selectPentoPiece', and 'startGame'. Either include them or remove the dependency array.",["196"],"React Hook useEffect has a missing dependency: 'initializationMonitor'. Either include it or remove the dependency array.",["197"],"no-redeclare","'block' is already defined.","redeclared","'y' is already defined.","'Component' is defined but never used.","'pento_create_shape' is defined but never used.","'title' is assigned a value but never used.","'pento_config' is assigned a value but never used.","'pento_read_only' is assigned a value but never used.","'pento_lock_on_grid' is assigned a value but never used.","'pento_prevent_collision' is assigned a value but never used.","'pento_active_shape' is assigned a value but never used.","'remove_at_rightclick' is assigned a value but never used.","'deactivate_at_canvasleave' is assigned a value but never used.","Expected '!==' and instead saw '!='.","'i' is already defined.","'left_edge' is assigned a value but never used.","'right_edge' is assigned a value but never used.","'upper_edge' is assigned a value but never used.","'lower_edge' is assigned a value but never used.","'get_shapes' is assigned a value but never used.","'get_actions' is assigned a value but never used.","'get_shape' is assigned a value but never used.","'clear_selections' is assigned a value but never used.","React Hook useEffect has missing dependencies: 'draw', 'init_board', and 'init_grid'. Either include them or remove the dependency array.",["198"],"'columns' is assigned a value but never used.","'rows' is assigned a value but never used.","'shape_config' is assigned a value but never used.","'action_counter' is assigned a value but never used.","default-case","Expected a default case.","SwitchStatement","missingDefaultCase","'matrix' is already defined.","'x_sum' is assigned a value but never used.","'y_sum' is assigned a value but never used.",{"desc":"199","fix":"200"},{"desc":"201","fix":"202"},{"desc":"203","fix":"204"},{"desc":"205","fix":"206"},"Update the dependencies array to be: [gameState.game.status, initialShapes, pentoPieceToObj, sendDataToFurhat]",{"range":"207","text":"208"},"Update the dependencies array to be: [placeSelected, selectPentoPiece, startGame]",{"range":"209","text":"210"},"Update the dependencies array to be: [initializationMonitor]",{"range":"211","text":"212"},"Update the dependencies array to be: [shapes, activeShape, init_board, init_grid, draw]",{"range":"213","text":"214"},[6337,6360],"[gameState.game.status, initialShapes, pentoPieceToObj, sendDataToFurhat]",[7589,7591],"[placeSelected, selectPentoPiece, startGame]",[7830,7832],"[initializationMonitor]",[5016,5037],"[shapes, activeShape, init_board, init_grid, draw]"]